#include <stdio.h>
#include <stdlib.h>

#define NX 128
#define NY 128
#define NZ 128 

double phi[4][NX][NY][NZ];

int main (int argc, char *argv[] ) {

  int ic, jc, kc;
  int nx, ny, nz;
  int LX, LY, LZ;
  int ascii,nr;
  double sop1, sop2, d1, d2, d3, d4;
  char opfilename[60];
  char dirfilename[60];
  char mode[60];

  FILE * fp;
  FILE * fp_out;
  FILE * fd_out;
      
  
  printf("hello %d \n", argc);
  printf("number of arguments %d \n", argc);

  if ( argc < 6 ) /* argc should be 5 for correct execution */
   {
        /* We print argv[0] assuming it is the program name */
        printf( "usage: %s filename LX LY LZ ascii/binary\n", argv[0] );
	exit(0);
    }
    else 
    {
        // We assume argv[1] is a filename to open
        fp = fopen( argv[1], "r" );

        /* fopen returns 0, the NULL pointer, on failure */
        if ( fp == NULL )
        {
            printf( "Could not open file\n" );
	    exit(0);
        }
        
	LX = atoi(argv[2]);
	LY = atoi(argv[3]);
	LZ = atoi(argv[4]);
	//mode = argv[5];
	//printf("input format %s\n",argv[5]);
	if (strncmp(argv[5],"ascii",5)==0){
	    ascii=1;
	    printf("ascii input file\n");
	}
	else if(strncmp(argv[5],"binary",6)==0){
	    ascii=0;
	    printf("binary input file\n");
	}
	else{
	    printf("wrong mode: %s\n", argv[5]);
	exit(0);
	}

	    
	    
	    
    }
  
  sprintf(opfilename,"op-%s.vtk", argv[1]);
  printf("order parameter output file %s \n", opfilename);
  
  sprintf(dirfilename,"dir-%s.vtk", argv[1]);
  printf("directory output file %s \n", dirfilename);
  
  fp_out = fopen(opfilename, "w");
  fd_out = fopen(dirfilename, "w");
  if (fp_out == NULL) exit(-1);
  if (fd_out == NULL) exit(-1);

  /* write the header information */
  fprintf(fp_out, "# vtk DataFile Version 2.0\n");
  fprintf(fd_out, "# vtk DataFile Version 2.0\n");

  fprintf(fp_out, "Generated by jep jep\n");
  fprintf(fd_out, "Generated by jep jep\n");

  fprintf(fp_out, "ASCII\n");
  fprintf(fd_out, "ASCII\n");

  fprintf(fp_out, "DATASET STRUCTURED_POINTS\n");
  fprintf(fd_out, "DATASET STRUCTURED_POINTS\n");

  fprintf(fp_out, "DIMENSIONS %d %d %d\n", LX, LY, LZ);
  fprintf(fd_out, "DIMENSIONS %d %d %d\n", LX, LY, LZ);

  fprintf(fp_out, "ORIGIN %d %d %d\n", 0, 0, 0);
  fprintf(fd_out, "ORIGIN %d %d %d\n", 0, 0, 0);

  fprintf(fp_out, "SPACING %d %d %d\n", 1, 1, 1);
  fprintf(fd_out, "SPACING %d %d %d\n", 1, 1, 1);

  fprintf(fp_out, "POINT_DATA %d\n", LX*LY*LZ);
  fprintf(fd_out, "POINT_DATA %d\n", LX*LY*LZ);

  fprintf(fp_out, "SCALARS order_parameter float %d\n", 1);
  fprintf(fd_out, "SCALARS director float %d\n", 3);

  fprintf(fp_out, "LOOKUP_TABLE default\n");
  fprintf(fd_out, "LOOKUP_TABLE default\n");

  
  
  

  
  for (ic = 0; ic < LX; ic++) {
    for (jc = 0; jc < LY; jc++) {
      for (kc = 0; kc < LZ; kc++) {
	  
	  if (ascii==1){
	      fscanf(fp, "%le %le %le %le %le",
		     &sop1,&d1, &d2, &d3, &d4);

	      phi[0][ic][jc][kc] = sop1;

	if(d1>=0){
	      phi[1][ic][jc][kc] = d1;
	      phi[2][ic][jc][kc] = d2;
	      phi[3][ic][jc][kc] = d3;
	}
	else if(d1<0){
		phi[1][ic][jc][kc] = -d1;
              	phi[2][ic][jc][kc] = -d2;
              	phi[3][ic][jc][kc] = -d3;	
	}
	  }
	  else
	  {
	      for (nr=0;nr<4;nr++){
		  fread(&sop1, sizeof(double), 1, fp);
		  phi[nr][ic][jc][kc] = sop1;
	      }
	  }
      }
    }
  }

  for (kc = 0; kc < LZ; kc++) {
    for (jc = 0; jc < LY; jc++) {
      for (ic = 0; ic < LX; ic++) {
	/*
	nx = (ic + 0) % NX;
	ny = (jc + 0) % NY;
	nz = (kc + 0) % NZ;
	*/
	  fprintf(fp_out, "%13.6e \n",phi[0][ic][jc][kc]);
	  fprintf(fd_out, "%13.6e %13.6e %13.6e \n",phi[1][ic][jc][kc],phi[2][ic][jc][kc], phi[3][ic][jc][kc]);
      }
    }
  }

  fclose(fp);
  fclose(fp_out);
  fclose(fd_out);

  return 0;
}
